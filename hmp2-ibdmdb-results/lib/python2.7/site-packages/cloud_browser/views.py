"""Cloud browser views."""
from django.http import HttpResponse, Http404
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.utils.importlib import import_module

from cloud_browser.app_settings import settings
from cloud_browser.cloud import get_connection, get_connection_cls, errors
from cloud_browser.common import get_int, \
    path_parts, path_join, path_yield, relpath, path_list
import os.path, time, sys

MAX_LIMIT = get_connection_cls().cont_cls.max_list


def settings_view_decorator(function):
    """Insert decorator from settings, if any.

    .. note:: Decorator in ``CLOUD_BROWSER_VIEW_DECORATOR`` can be either a
        callable or a fully-qualified string path (the latter, which we'll
        lazy import).
    """

    dec = settings.CLOUD_BROWSER_VIEW_DECORATOR

    # Trade-up string to real decorator.
    if isinstance(dec, basestring):
        # Split into module and decorator strings.
        mod_str, _, dec_str = dec.rpartition('.')
        if not (mod_str and dec_str):
            raise ImportError("Unable to import module: %s" % mod_str)

        # Import and try to get decorator function.
        mod = import_module(mod_str)
        if not hasattr(mod, dec_str):
            raise ImportError("Unable to import decorator: %s" % dec)

        dec = getattr(mod, dec_str)

    if dec and callable(dec):
        return dec(function)

    return function


def _breadcrumbs(path):
    """Return breadcrumb dict from path."""

    full = None
    crumbs = []
    for part in path_yield(path):
        full = path_join(full, part) if full else part
        crumbs.append((full, part))

    return crumbs


@settings_view_decorator
def browser(request, path='', template="cloud_browser/browser.html"):
    """View files in a file path.

    :param request: The request.
    :param path: Path to resource, including container as first part of path.
    :param template: Template to render.
    """
    from itertools import ifilter, islice

    # KRB
    path = path.replace("%20", " ")
    path = path.replace("%3A", ":")
    # import sys; print >> sys.stderr, path

    # Inputs.
    container_path, object_path = path_parts(path)
    incoming = request.POST or request.GET or {}

    marker = incoming.get('marker', None)
    marker_part = incoming.get('marker_part', None)
    if marker_part:
        marker = path_join(object_path, marker_part)

    # Get and adjust listing limit.
    limit_default = settings.CLOUD_BROWSER_DEFAULT_LIST_LIMIT
    limit_test = lambda x: x > 0 and (MAX_LIMIT is None or x <= MAX_LIMIT - 1)
    limit = get_int(incoming.get('limit', limit_default),
                    limit_default,
                    limit_test)

    # Q1: Get all containers.
    #     We optimize here by not individually looking up containers later,
    #     instead going through this in-memory list.
    # TODO: Should page listed containers with a ``limit`` and ``marker``.
    conn = get_connection()
    containers = conn.get_containers()

    marker_part = None
    container = None
    objects = None
    if container_path != '':
        # Find marked container from list.
        cont_eq = lambda c: c.name == container_path
        cont_list = list(islice(ifilter(cont_eq, containers), 1))
        if not cont_list:
            raise Http404("No container at: %s" % container_path)

        # Q2: Get objects for instant list, plus one to check "next".
        container = cont_list[0]
        objects = container.get_objects(object_path, marker, limit+1)
        marker = None

        # If over limit, strip last item and set marker.
        if len(objects) == limit + 1:
            objects = objects[:limit]
            marker = objects[-1].name
            marker_part = relpath(marker, object_path)

    return render_to_response(template,
                              {'path': path,
                               'marker': marker,
                               'marker_part': marker_part,
                               'limit': limit,
                               'breadcrumbs': _breadcrumbs(path),
                               'container_path': container_path,
                               'containers': containers,
                               'container': container,
                               'object_path': object_path,
                               'objects': objects},
                              context_instance=RequestContext(request))

def walk(topdir, target):
    myfiles = []
    for topdir, dirs, files in os.walk(topdir, target):
        for file in files:
            if file.endswith(target):
                myfiles.append(os.path.join(topdir, file))
    return myfiles

def convert_to_web(files, branch):
    result = []
    for file in files:
        #import sys; print >> sys.stderr, "file: ", file
        filesegs = path_list(file)[3:]
        filesegs.insert(0,branch)
        
        f = path_join(*filesegs)
        #import sys; print >> sys.stderr, "newfile: ", f
        result.append("/tunnel/cb/document/" + f)
    return result 

@settings_view_decorator
#def document(_, path=''):
def document(request, path='', template="hmp2-status-doc.html"):
    """View single document from path.

    :param path: Path to resource, including container as first part of path.
    """
    # KRB
    path = path.replace("%20", " ")
    path = path.replace("%3A", ":")
    #import sys; print >> sys.stderr, "view: document"

    container_path, object_path = path_parts(path)
    conn = get_connection()
    try:
        container = conn.get_container(container_path)
    except errors.NoContainerException:
        raise Http404("No container at: %s" % container_path)
    except errors.NotPermittedException:
        raise Http404("Access denied for container at: %s" % container_path)
    #import sys; print >> sys.stderr, path_list(path)[-2]

    
    if path_list(path)[-2] == "mibc_products" and path_list(path)[-1] == "pcoa.html" or \
        path_list(path)[-1] == "barchart.html" or path_list(path)[-1] == "heatmap.html":

        if path_list(path)[-1] == "pcoa.html":
            pcoa = "pcoa"
            barchart = None
            heatmap = None
        elif path_list(path)[-1] == "barchart.html":
            barchart = "barchart"
            pcoa = None
            heatmap = None
        else:
            heatmap = "heatmap"
            pcoa = None
            barchart = None
        #import sys; print >> sys.stderr, "test"
        rawfiles = []
        productfiles = []
        startpath = "/seq/ibdmdb/data_deposition/" + '/'.join(path_list(path)[1:-2])
        startdate = time.ctime(os.path.getctime(startpath))
        finishpath = "/seq/ibdmdb/public/" + '/'.join(path_list(path)[1:-1])
        finishdate = time.ctime(os.path.getctime(finishpath))
        user = path_list(path)[-3]
        week = path_list(path)[-4]
        type = path_list(path)[-5]
        study = path_list(path)[-6]
        run = 1 # THIS MUST BE MADE DYNAMIC KRB

        data_extensions = []
        sanitized_type = type
        #print >> sys.stderr, "path: " + path
        
        if type == "16S":
            data_extensions = ['.fa', '.fq']
            rawpath = "/seq/ibdmdb/processing/" + '/'.join(path_list(path)[1:-1])
            print >> sys.stderr, "rawpath: " + rawpath
            #possible_rawfiles = walk(rawpath)
            for root, dirs, files in os.walk(rawpath):
                for file in files:
                    #print >> sys.stderr,"poss rawfile: " + file
                    if os.path.splitext(file)[-1] in data_extensions:
                        #print >> sys.stderr,"rawfile: " + os.path.join(root,file)
                        rawfile = os.path.join(root, file).split('mibc_products/')[1]
                        rawfiles.append("mibc_products/" + rawfile)
            # convert rawpath to web accessible path
            rawpath = "/tunnel/cb/document/Processing/" + '/'.join(path_list(path)[1:-2])

            productpath = "/seq/ibdmdb/public/" + '/'.join(path_list(path)[1:-1])
            tmpfiles = walk(productpath, "biom")
            for file in tmpfiles:
                productfiles.append(file.split('mibc_products/')[1])
            # convert rawpath to web accessible path
            productpath = "/tunnel/cb/document/Public/" + '/'.join(path_list(path)[1:-1])

        elif type == "WGS":
            sanitized_type = "Metegenomes"
            rawpath = "/seq/ibdmdb/processing/" + '/'.join(path_list(path)[1:-2])
            tmpfiles = os.listdir(rawpath)
            for file in tmpfiles:
                if os.path.isfile(os.path.join(rawpath, file)):
                    rawfiles.append(file)
            # convert rawpath to web accessible path
            rawpath = "/tunnel/cb/document/Processing/" + '/'.join(path_list(path)[1:-2])

            productpath = "/seq/ibdmdb/processing/" + '/'.join(path_list(path)[1:-1])
            productfiles = []
            tmpfiles = walk(productpath, "metaphlan2")
            for file in tmpfiles:
                productfiles.append(path_list(file)[-1])
            #print >> sys.stderr, "productpath:", productpath
            # convert rawpath to web accessible path
            productpath = "/tunnel/cb/document/Processing/" + '/'.join(path_list(path)[1:-1])
            
        #print >> sys.stderr, "productpath:", productpath
        #print >> sys.stderr, "productfiles:", productfiles
        try:
            dum, extension = os.path.splitext(rawfiles[0])
        except IndexError:
            print >> sys.stderr, "IndexError: "
            
        #print >> sys.stderr, "ext:", extension
        if extension == ".fq" or extension == ".fastq" or extension == ".fq.gz":
            rawtype = "fastq"
        elif extension == ".fa" or extension == ".fasta" or extension == ".fa.gz":
            rawtype = "fasta"
        elif extension == ".sff":
            rawtype = "454"
        else:
            rawtype = "unk" 
        # convert rawpath to web accessible path
        return render_to_response(template,
                              {'path': path,
                               'pcoa': pcoa,
                               'barchart': barchart,
                               'heatmap': heatmap,
                               'sdate': startdate,
                               'fdate': finishdate,
                               'week': week,
                               'user': user,
                               'type': sanitized_type,
                               'run': run,
                               'study': study,
                               'rawtype': rawtype,
                               'rawpath': rawpath,
                               'rawfiles': rawfiles,
                               'productpath': productpath,
                               'productfiles': productfiles,
                               'productfilerange' : range(len(productfiles))},
                              context_instance=RequestContext(request))

    elif path_list(path)[-1] == "summary.html":

        template="hmp2-summary-doc.html"
        # get all *.html files in public folder that resize immediately under a 'mibc_products' directory
        # strip out summary.html file itself
        tmpfiles = walk("/seq/ibdmdb/public", ".html")
        for tfile in list(tmpfiles):
            if "/seq/ibdmdb/public/summary.html" in tmpfiles:
                tmpfiles.remove(tfile)
                continue
            tfilesegs = tfile.split("/")
            indx = tfilesegs.index('mibc_products')
            if indx != len(tfilesegs) - 2:
                tmpfiles.remove(tfile)

        htmlfiles = convert_to_web(tmpfiles, "Public")
        types = []
        week = []
        study = []
        detail = []
        for file in htmlfiles:
            study.append(path_list(file)[4])
            if path_list(file)[5] == 'WGS':
                types.append("Metagenomes")
            else:
                types.append(path_list(file)[5])
            theweek = "20" + path_list(file)[6]
            theweek = theweek[:4] + '.' + theweek[4:]
            week.append(theweek)
            detail.append(path_list(file)[9])
        return render_to_response(template,
                              {'path': path,
                               'size': len(htmlfiles),
                               'range': range(len(htmlfiles)),
                               'types': types,
                               'study': study,
                               'week': week,
                               'detail': detail,
                               'htmlfiles': htmlfiles},
                              context_instance=RequestContext(request))






    else:
        try:
            storage_obj = container.get_object(object_path)
        except errors.NoObjectException:
            raise Http404("No object at: %s" % object_path)

        # Get content-type and encoding.
        content_type = storage_obj.smart_content_type
        # import sys; print >> sys.stderr, content_type
        encoding = storage_obj.smart_content_encoding
        response = HttpResponse(content=storage_obj.read(),
                            content_type=content_type)
        if encoding not in (None, ''):
            response['Content-Encoding'] = encoding

        return response
